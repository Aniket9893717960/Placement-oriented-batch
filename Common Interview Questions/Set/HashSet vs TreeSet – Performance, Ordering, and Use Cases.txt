                         WHAT IS HASHSET?
HashSet is a class in Java that belongs to the Collection Framework and 
implements the Set Interface. It is used to store unique elements only
- meaning no duplicates are Allowed.
Internally, HashSet is backed by a HashMap. Even through u use a Set, 
it actually puts data inside a HashMap behind the scenes.

   # Key Properties Of HashSet:
i. If u try to add a duplicate value, it will not be inserted.
ii. It does not maintain the order of insertion or sorting.
iii. U can insert one null element into a HashSet.
iv. On average, operations like add(), remove(), contains() are O(1).
v. Internally uses a hash table through a HashMap instance.

   #Internal Working Of HashSet: 
Here's how "HashSet" works step by step:
 1. When u add an element to a "HashSet", like "set.add("Apple")", it is 
    actually calling "map.put("Apple", PRESENT)" in the background.
 2. The value "Apple" is used as the key in the internal "HashMap", and
    a constant dummy value is used as the value.
 3. The object's hashCode() method determines where to store the value in
    the hash table (bucket).
 4. It two objects have the same hash code,It uses the "equals" method to
    check if they are actually the same.

This ensures that duplicates are not stored.

 CODE EXAMPLE OF HashSet:
  import java.util.HashSet;
  public class HashSetExample {
    public static void main(String[] args){
    HashSet<String> set = new HashSet<>();
    set.add("Apple");
    set.add("Banana");
    set.add("Mango");
    set.add("Banana"); // Duplicate - won't be added
    System.out.println(set);
    //Output might be: [Banana, Apple, Mango]
    // Order is not guaranteed
    }
  }

 #NOTE:
  HashSet is not synchronized. if multiple threads access it, use
  'Collections.synchronizedSet()' or "ConcurrentSkipListSet" if u want
  thread safety.

                         WHAT IS TREESET?
TreeSet is also part of Java's Collection framework and implements the
NavigableSet and SortedSet interfaces. Unlike "HashSet", it maintains
elements in sorted order.
It is implementes using a Red Black Tree, which is a type of self 
balancing binary search tree(BST).

  # Key Properties of TreeSet:
i. Just like "HashSet", it stores only unique elements.
ii. Elements are always sorted (natural or custom order).
iii. If u insert "null" and TreeSet uses natural order, it throws NPE.
iv. Operations like add(), remove(), contains() take O(log n) time.
v. A kind of self balancing binary search tree to keep data sorted.

  # Internal Working of TreeSet:
Here's how "TreeSet" stores elements:
 1. When u add an element, it uses 'compareTo()'(natural ordering) or
    a 'Comparator'(custom order) to decide where the element goes.
 2. It places elements in a binary search tree structure, ensuring the 
    tree remains balanced (via Red-Black Tree logic).
 3. If u try to insert a duplicate element, the tree detects it via 
    comparison and ignores it.
 4. If u try to insert 'null', and 'compareTo()' is called
    (which happens during sorting), it throws a "NullPointerException".

  # Code Example of TreeSet:
   import java.util.TreeSet;
    public class TreeSetExample {
     public static void main(String[] args){
      TreeSet<String> set = new TreeSet<>();
      set.add("Banana");
      set.add("Apple");
      set.add("Mango");
      set.add("Apple"); // Duplicate - will not be added
      System.out.println(set);
      // Output: [Apple, Banana, Mango]
      // Elements are Sorted alphabetically
     }
    }

  # Note:
  *"TreeSet" does not allow null elements if u are using natural 
   ordering.
  *But if u Use a custom comparator that can handle 'null', then it
   might allow it (rare case).
  *It's slower than 'HashSet', but more powerful if u need sorting or
   range based operations like 'headSet()','tailSet()' or 'subSet()'.

                       SUMMARY COMPARISON
Feature                    HeahSet                          TreeSet
Duplicate                Not Allowed                      Not Allowed
   Values
Ordering                 Not Ordering                Maintains natural
                                                    or custom ordering
Null Values              One null Allowed           Null not Allowed
                                                    (in natural order)
Performance               Fast (O(1))                Slower (O(log n))
Backed By                   HashMap                   Red Black Tree
Sorting                  Not Supported                Automatically
                                                         Sorted
Thread                        No                           No
 Safe

                    REAL LIFE EXAMPLE USE CASES
When to use "HashSet":
              You need to store a set of unique values and don't care
                about order
              You want Fast Access, insertion, and deletion
              Example:
                Store unique email IDs
                Caching unique IP address
When to use "TreeSet":
                You need to store a set of 

CAN U GIVE ME A HIGH - LEVEL OVERVIEW OF THE PROJECT'S ARCHITECTURE?
The project is a full stack URl Shortener Application with a 
decoupled architecture. We designed it with a clear separation
between the frontend and the backend to make it scalable and 
easier to maintain.

On the backend, we build a RESTful API using Spring Boot.
We chose Spring Boot because it allowed us to set up a production
- ready application quickly. It handles all the core business
logic.
 i.Generating short codes for long URLs.
 ii. Handling the redirection logic.
 iii. Managing user authentication and authorization using 
      Spring security and JWTs(JSON Web Tokens).
 iv. For the database, we used MySQL, and we interacted with 
     it through Spring Data JPA, which simplified our database
     Operations a lot. The backend exposes a set of REST endpoints
     that the frontend can consume.

WHAT WAS YOUR ROLE IN THIS PROJECT? WHAT PRATS DID U WORK ON PRIMARILY?
 In this project, I Worked as a BackEnd Developer, through i build
 a user authentication and security features, which meant i got to 
 work extensively on backend.
 In backend, my primary responsibility was to implement the entire 
 authentication and authorization flow. This involved:
        *Setting up Spring Security from the ground up.
   *I build the AuthController, which exposes the REST endpoints
   for user registration (/api/auth/public/register) and login
   (/api/auth/public/login).
  *I was responsible for implementing the JWT(Json Web Token) logic
 for generating a token upon successful login and validating token
 on subsequent requests. This included creating the JWT utility classes
 and integrating them into Spring Security's filter chain.
 *I also configured the security rules to protect the URL management 
 endpoints, ensuring that only autheticated users could create short
 links or view their dashboard.

CAN U WALK ME THROUGH HOW U IMPLEMENTED AUTHENTICATION AND 
AUTHORIZATION IN YOUR PROJECT USING SPRING SECURITY AND JWT? 
SPECIFICALLY, I'D LIKE TO UNDERSTAND "WEBSECURITYCONFIG" SETUP,
YOUR CUSTOM JWT FILTER, AND HOW U TRIED IT TOGETHER WITH THE 
"USERDETAILS" SERVICE.

 1. Core Security Confiuration(WebSecurityConfig): This is where i laid
    ------------------------------- the foundation. if u look at 
    'WebSecurityConfig", u'll see I used the '@EnableWebSecurity'
  annotation to enable Spring's web security support. The most critical
 part is the SecurityFilterChain bean:

  // Inside 'WebSecurityConfig.java'
 @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http)
 throws Exception {
 http.csrf(AbstractHttpConfigure::disable)
 .exceptionHandling(exception -> 
exception.authenticationEntryPoint(unauthorizedHandler))
 .sessionManagement(session -> 
session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
.authorizeHttpRequests(auth ->
  auth.requestMatchers("/api/auth/public/**").permitAll()
  .requestMatchers("/{shortURL}").permitAll()
  .anyRequest().authenticated());
 http.authenticationProvider(authenticationProvider());
 http.addFilterBefore(authenticationJwtTokenFilter(), 
        UsernamePasswordAuthernticationFilter.class); 
 return http.build(); }

 EXPLAIN THE ALGORITHM YOU USED TO GENERATE SHORT URLs. Did You 
       CONSIDER COLLISIONS?
To generate short URLs, I implemented a Base62 encoding approach,
which converts a unique database ID into a compact, alphanumeric string.
  i. Input: A unique long ID (auto-incremented primary key
                              from the "UrlMapping" table).
  ii. Conversion Logic:
   Divide the ID by 62 and map the remainder to a character in the set
   Repeat until the ID becomes 0.
   Reverse the resulting string to get the short code.
 iii. Advanteges:
   Predictable: No randomness, ensuring deterministic output.
        Collision Handling:
While Base62 encoding itself is collision-free
(since each ID maps to a unique string), I implemented additional safeguards:

How did JWT AND SPRING SECURITY INTEGRATE INTO THIS PROJECT? What
ENDPOINTS WERE SECURED? 
   1. JWT (JSON WEB TOKEN) Implementation.
To enable stateless authentication and secure API endpoints by validating user identity and permissions.
Components:
  JwtUtils:Handles token generation, validation and extraction of claims
           (e.g., username, roles).
  JwtAuthenticagtionFilter: Intercepts requests, validates tokens and 
                            sets the SecurityContext.
  JwtAuthenticationResponse: DTO to return the token to the client after
                             login.

   2. Security Best Practices Applied
 i. JWT Security:
    Signed with HMAC-SHA256 ------|
                                  |
HMACSHA256 Is a type of keyed hash algorithm that combines the
SHA-256 hash function with a secret key to produce a 
Hash - based Message Authentication Code(HMAC).
This algorithm is widely used to ensure integrity and authenticity of a
message especially when transmitted over insecure channels.

ii. Input Validation:
       Used @Valid on DTOs (e.g., LoginRequest) to reject malformed
       inputs.
iii. CSRF Protection: Disabled for stateless APIs
                     (since JWT is immune to CSRF).
iv. Rate Limiting: Add Spring Security rate limiting for "/login" and
                   "/register".

  3. Challenges & Solutions:
 i. Challenges: Token revocation(e.g., logout)
Solution: Short - Lived Tokens (Simpler)
 a. Configure Token Expiration
   In "application.properties":
              jwt.expiration=86400000  # 24 hours in milliseconds
   In "JwtUtils.java":
              public String generateToken(UserDetailsImpl userDetails){
              //Set expiration from properties
              return Jwts.builder()
              .subject(userDetails.getUsername())
              .issuedAt(new Date())
              .expiration(new Date(System.currentTimeMillis()
               + jwtExpirationMs))
              .signWith(getSigningkey())
              .compact();
              }
  b. Force Re-login After Expiry
      Clients must refresh tokens by re-authenticating after 24 hours.
      No server side storage needed.

   WHY USE SPRING DATA JPA OVER PLAIN JDBC? WHAT WERE THE ADVANTAGES?
1. Reduced Boilerplate Code
     Problem with JDBC:
       Required manual:
          Connection Management
          SQL query strings
          ResultSet to object mapping
          Transaction handling
     Spring Data JPA Solution
CODE:
public interface UrlMappingRepository extends JpaRepository<UrlMapping, Long> {
Optional<UrlMapping> findByShortUrl(String shortUrl); // Auto-implemented
}
   No SQL: Methods like "findByShortUrl()" generate optimized queries
           automatically
   No manual Mapping: Entities map directly to tables.

2. Built - in CRUD Operations:
     JDBC: Write Insert, Update, Delete queries manually.
     JPA: Inherits ready to use methods:
    url.MappingRepository.save(entity) // Handles both insert/update

         ---------------NOTE--------------
save() checks if the entity is new (e.g., ID is null). If new, it 
performs an INSERT; otherwise, it merges changes with an UPDATE. 
However, this can 
be inefficient for updates because it may trigger a 
redundant SELECT. In my URL shortener, I used save() for new links but 
optimized updates with @Modifying queries when possible
        ----------------X-----------------

 WHY USE SPRING DATA JPA OVER PLAIN JDBC? WHAT WERE THE ADVANTAGES?
1. Reduced Builerplate Code:
    Problem with JDBC:
      Requires manual:
        Connection management
        SQL query strings
        ResultSet to object mapping
        Transaction handling
    Spring Data JPA Solution:
CODE:
public interface UrlMappingRepository extends JpaRepository<UrlMapping, 
Long>{
  Optional<UrlMapping> findBySortUrl(String sortUrl);
}

No SQL: Methods like 'findByShortUrl()' generate optimized queries 
automatically.
No Manual mapping:
  Entities (e.g., UrlMapping) map directly to tables.

2. Built - in CRUD Operations
  JDBC: Write INSERT, UPDATE, DELETE queries manually.
  JPA: inherits ready-to-use methods:
CODE:
urlMappingRepository.save(entity); // andles both insert/update
             urlMappinRepository.deleteById(id);

3. Transaction Management
   JDBC: Manual commit()/rollback().
   JPA: Declaration transaction with '@Transactional'
CODE
    @Transactional
    public void trackClick(String shortUrl){
UrlMapping url = 
urlMappingRepository.findByShortUrl(ShortUrl).orElsrThrow();
url.setClickCount(url.getClickCount()+1); //Auto-saved on method exit
    }
4. Performance Optimizations
   Lazy Loading:
CODE
    @OneToMany(mappedBy = "urlMapping", fetch = FetchType.LAZY)
    private List<ClickEvent> clickEvents; //Loaded only when

   Caching: First - level cache (Persistence Context) reduces
            database hits.
5. Database Portability
   JDBC: SQL queries may need rewriting for different databases.
         (e.g., MySQL -> PostgreSQL)
   JPA : Uses Hibernate's dialect system to auto - generate 
         vendor - specific SQL.
6. Type Safety
  JDBC: Risk of SQL injection or typos in query strings:
CODE:
    String sql = "SELECT * FROM url_mapping" WHERE short_url = ''
  JPA: Compile - time checks:
CODE:
    findByShortUrl(String shortUrl);
     // Compiler validates method name/parameters
7. Auditing & Hooks
    Automatic timestamps:
CODE
    @EntityListeners(AuditingEntityListener.class)
    public class UrlMapping {
      @CreatedDate
      private LocalDateTime createdDate;
    }
8. Integration with Spring Ecosystem
     Pagination:
CODE:
      Page<UrlMapping> findAll(Pageable pageable);
       // Auto-handle Limit/offset

     QueryDSL Support: 
      Type - safe dynamic queries.

  HOW DID YOU HANDLE REDIRECTS FROM SHORT URLS TO ORIGINAL URLS?
1. High - Level Approach
  The redirection mechanism follows REST principles and leverages
  HTTP 302 (Temporary Redirect) to ensure:
    Minimal latency (critical for user experience).
    Accurate click tracking (for analytics).
    Scalability (stateless, cache-friendly).

2. Implementation Details
   A. Database Lookup
      Schema:
CODE
    @Entity
    public class UrlMapping {
        @Id
        private String shortUrl;
            // Key: Base62 - encoded ID (e.g., "abc123")
        private String originalUrl;
        private int clickCount;
    }
      Lookup Logic:
CODE
    public UrlMapping getOriginalUrl(String shortUrl){
        return urlMappingRepository.findByShortUrl(shortUrl)
            .orElseThrow(() -> new NotFoundException("URL not found"));
    }
  B. Redirect Flow
        Client Request:
            GET /abc123
        Backend:
            Fetch originalUrl from the database.
            Increment clickCount.
            Log ClickEvent (timestamp, IP, etc.) for analytics.
        HTTP Response:  CODE:
            HTTP/1.1 302 Found
            Location: https://original-domain.com/long-path
  C. Spring Boot Controller
        @RestController
        public class RedirectController {
            private final UrlMappingService urlMappingService;

            @GetMapping("/{shortUrl}")
   public ResponseEntity<Void> redirect(@PathVariable String shortUrl){
    UrlMapping mapping = urlMappingService.getOriinalUrl(shortUrl);
    
          }
        }

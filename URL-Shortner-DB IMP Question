CAN U WALK ME THROUGH HOW U IMPLEMENTED AUTHENTICATION AND 
AUTHORIZATION IN YOUR PROJECT USING SPRING SECURITY AND JWT? 
SPECIFICALLY, I'D LIKE TO UNDERSTAND "WEBSECURITYCONFIG" SETUP,
YOUR CUSTOM JWT FILTER, AND HOW U TRIED IT TOGETHER WITH THE 
"USERDETAILS" SERVICE.

 1. Core Security Confiuration(WebSecurityConfig): This is where i laid
    ------------------------------- the foundation. if u look at 
    'WebSecurityConfig", u'll see I used the '@EnableWebSecurity'
  annotation to enable Spring's web security support. The most critical
 part is the SecurityFilterChain bean:

  // Inside 'WebSecurityConfig.java'
 @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http)
 throws Exception {
 http.csrf(AbstractHttpConfigure::disable)
 .exceptionHandling(exception -> 
exception.authenticationEntryPoint(unauthorizedHandler))
 .sessionManagement(session -> 
session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
.authorizeHttpRequests(auth ->
  auth.requestMatchers("/api/auth/public/**").permitAll()
  .requestMatchers("/{shortURL}").permitAll()
  .anyRequest().authenticated());
 http.authenticationProvider(authenticationProvider());
 http.addFilterBefore(authenticationJwtTokenFilter(), 
        UsernamePasswordAuthernticationFilter.class); 
 return http.build(); }

 2. The JWT Authentication Filter (JwtAuthFilter.java)
This is the custom Filter i just mentioned. It's the real workhorse
of the JWT validation process. It extends 
'OncePerRequeestFilter' to ensure it runs exactly once for every 
Request.
Inside its doFilterInternal method, I implemented this logic: CODE:
  //Inside JwtAuthFilter.java

 @Override protected void doFilterInternal(HttpServletRequest request,
   HttpServletResponse response, FilterChain filterChain) throws
   ServletException, IOException {
    try {
       String jwt = parseJwt(request);
     if(jwt!=null && jwtUtils.validateJwtToken(jwt)){
       String username = jwtUtils.getUserNameFromJwtToken(jwt);
       UserDetails userDetails = userDetailsService.loadUserByUsername
      (username);
      UsernamePasswordAuthenticationToken authentication = 
  new UsernamePasswordAuthenticationToken(userDetails, null, 
  userDetails.getAuthorities());
    authentication.setDetails(new WebAuthenticationDetailsSource().
      buildDetails(request));
   SecurityContextHolder.getContext().setAuthentication(authentication);
  } } catch(Exception e){ logger.error("CannotSetUserAuthentication: {
}",e); }
 filterChain.doFilter(request, response);
     }
    }
   }

3. JWT Generation and Utilities (JwtUtils.java And AuthController.java)
The JwtUtils.java class is a helper I created to handle the JWT 
mechanics using the 'io.jsonwebtoken.jjwt' library. it has two main
methods: 'generateJwtToken' and 'ValidateJwtToken'.
I used the 'generateJwtToken' method within the 'AuthController.java'
after a user successfully logs in:
         // Inside AuthController.java
 @PostMapping("/public/login")
 public ResponseEntity<?> loginUser(@ResponseBody LoginRequest 
 loginRequest){
  String jwt = jwtUtils.generateToken(authentication);
 }

So, putting it all together:
 *A user logs in via the AuthController.
 *If successful, JwtUtils generates a token.
 *For all subsequent requests to protected endpoints, my JwtAuthFilter
 kicks in, uses 'JwtUtils' to validate the token, and then uses 
 'UserDetailsServiceImpl' to load the user and set the security 
 context. 
 *And all of this is orchestrated by the rules I defined in 
 'WebSecurityConfig'.

 WHAT FLOW DID U IMPLEMENT FOR AUTHENTICATE USERS TO MANAGE THERE URLs?
       OR            DASHBOARD FOR AUTHENTICATED USERS?
          The Goal: Securely Fetch URLs for a Specific User
The core task is to create an API endpoint that, when called, returns
a list of URLs belonging only to the currently logging in user.
 Step 1: Security - Protecting the Endpoint: First, we must ensure only
 ------------------------------------------ authenticated users can ask
    for their URLs. This is done with Spring Security.
   *How: The 'UrlMappingController' uses the 
 '@PreAuthorize("hasRole('USER')")' Annotation. This acts as a guard. if
 a request comes from someone who is not logged in or doesn't have the 
 USER role, the system rejects it immediately with a "Forbidden" error.
 *Code (UrlMappingController.java):
  ---------------------------------
     @GetMapping("/myurls")
   @PreAuthorize("hasRole('USER')") // <-- This is Security Guard
 public ResponseEntity<Page<UrlMappingDTO>> getUserUrls(
       Principal principal,
@PageableDefault(size=10, sort="clickDate",direction = Sort.Direction.DESC)
Pageable pageable){ User user = 
userService.findByUsername(principal.getName());
try { Page<UrlMappingDTO> urls = urlMappingService.getUrlByUser(user,
 pageable); return ResponseEntity.ok(urls);
} catch (Exception e){ return 
ResponseEntity.status(HttpStatus.) }
}

 Step 2: Controller - Handling the incoming Request:
When the frontEnd dashboard loads,  it sends a GET request to
'/api/urls/myurls'. The controller's job is to catch this request,
identify the user, and delegate the work.

 *How: The controller gets a Principal object from Spring Security,
       which holds the logged in user's username. it then passes this
       information to the 'UrlMappingService' to handle the actual logic.
 *CODE (UrlMappingController.java):
        @GetMapping("/myurls")
        @PreAuthorize("hasRole('USER')")
        public ResponseEntity<Pagr<UrlMappingDTO>> getUserUrls(
      Principal principal, @PageableDefault(size = 10) Pageable pageable){
   User user = userSercive.findByUsername(principal.getName());
Page<UrlMappingDTO> urls = urlMappingService.getUrlsByUser(user, pageable);
 return ResponseEntity.ok(urls); }

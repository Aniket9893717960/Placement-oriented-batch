To remove duplicate in the list in java, there are multiple ways depending on the 
requirement. Here are the most common ones:

1. Using 'Set'(Simple and Fast): PROGRAM

List<String> list = new ArrayList<>(Array.asList("Apple","bunana","apple","orange"));
Set<String> set = new HashSet<>(list);
list = new ArrayList<>(Set);

System.out.println(list);
                   --------------X--------------
                                 NOTE
This does not preserve insertion order. If you want to keep the original order,
use LinkedHashSet.
                  --------------X--------------
1. Using 'Set'(Simple and Fast): Explaination
   CODE
      List<String> list = new ArrayList<>(Arrays.asList("apple", "banana", "apple", "orange"));
           What’s happening here?
'Arrays.asList(...)' creates a fixed-size list from the array: ["apple", "banana", "apple", "orange"]
'new ArrayList<>(...)' then creates a modifiable ArrayList from that list.
So now you have a List<String> with duplicate "apple" values.

   CODE
     Set<String> set = new HashSet<>(list); // Removes duplicates
               What’s happening here?
A HashSet is a collection that doesn't allow duplicates.
When you pass the list to a HashSet, it automatically removes the duplicates.
Order is not guaranteed in a HashSet, so the elements may get shuffled.

   CODE
     list = new ArrayList<>(set); // Convert back to List
               What’s happening here?
We convert the Set back to a List because:
Maybe you want list functionality (like accessing by index)
Or you're working with methods that expect a List
                    ----------------X---------------

2. Using 'LinkedHashSet'(Preserves Insertion Order)
   -----------------------------------------------
CODE
    List<String> list = new ArrayList<>(Arrays.asList("apple", "banana", "apple", 
        "orange"));
Set<String> set = new LinkedHashSet<>(list); // Removes duplicates and preserves 
                                                 order
list = new ArrayList<>(set);
System.out.println(list);
          CODE
      Set<String> set = new LinkedHashSet<>(list); // Removes duplicates and preserves order
           What happens here is:
You're creating a LinkedHashSet from that list.
why 'LinkedHashSet'? Because:
      it removes duplicates(like a normal Set)
      But also preserves the insertion order(unline HashSet)

3. Using Java 8+ Streams
   ---------------------
CODE
    List<String> list = new ArrayList<>(Arrays.asList("apple","banana","apple","orange"));
list = list.stream()
           .distinct()
           .collect(Collectors.toList());
System.out.println(list);

         what happends
'list.stream()' This convert the list into a Stream.
 -------------  A 'Stream<String>' is a pipeline of elements that supports 
                Various operations (like filtering, mapping, reducing, etc).
So, you're starting a stream pipeline.

'.distinct()' : This remove duplicate from the stream.
 -----------   It keeps only the first occurrence of each element
               (Just like 'LinkedHashSet' would do).
Behind the scenes, it uses a 'Set' to track which elements have been seen 
already.

'.collect(Collectors.toList())' : This collects the elements of the stream
 -----------------------------    back into a 'List'.
You're using 'Collectors.toList()' as a collector to accumulate the stream
elements into a new ArrayList.

4. Manual Way (Without Using Set or Stream)
   ----------------------------------------
CODE
    List<String> list =new ArrayList<>(Arrays.asList("apple","banana","apple","orange"));
List<String> result = new ArrayList<>();

for(String item : list){
   if(!result.contains(item)){
      result.add(item);
   }
}

System.out.println(result);
                      What Happens in CODE?
'for(String item : list)' This is an enhanced for loop(also called a "for-each 
 -----------------------   loop").
It goes through each element in the list, one by one.
The variable 'item' will hold the current element form the list during each loop
iteration.

'if (!result.contains(item))' This checks whether the result list already has the 
 ---------------------------  the current item.
'!result.contains(item)' meana : "If result does not contain the item yet..."

'result.add(item);' If the item is not already present in result, it adds the item.
 -----------------  This way, it only adds unique items.

5. Using Only loops and arrays(no Set, no Streams)
   -----------------------------------------------

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class RemoveDuplicateManual {
 public static void main(String[] args){
  List<String> list = new ArrayList<>
(Arrays.asList("apple","banana","apple","orange","banana"));

  List<String> result = new ArrayList<>();
  for(int i=0;i<list.size();i++){
    boolean found = false;
    for(int j=0; j<result.size(); j++){
      if(result.get(j).equals(list.get(i))){
        found = true;
        break;
      }
    }
   if(!found){
    result.add(current);
   }
  }
  System.out.println("List without duplicates: "+result);
 }
}

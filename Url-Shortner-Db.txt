         Give me an overview about Your Project?
Url shortener a full stack web application to convert long URLs 
into short, shareable links while providing analytics on click -
through rates.
I have used some technologies in backend like:
Framework: Spring Boot (Java)
Database: MySQL (Stores users, URL mappings, and click events)
Authentication: JWT (Stateless, role-based access control)
APIs: RESTful endpoints for URL shortening,
       redirection and analytics.
   i. URL Shortening:
  Use Base62 encoding for compact, collision-resistant short codes.
  ii. Redirection:
  Handles high-volume redirects (HTTP 302) with minimal latency.
  iii. User Authentication:
  Secure registration/login using JWT tokens.
  Role-based access (e.g., ROLE_USER for basic features).
  iv. Analytics Dashboard:
  Visualizes click -through rates, geographic data(if implemented)
  and peak traffic times.
  support date-range filtering and pagination.
  v. Scalability:
  Stateless backend architecture for horizontal scaling.
  Caching (Redis) for frequently 
         Architecture:
             3-Tier Design:
                  Presentation Layer: React frontend (if applicable).
                  Application Layer: 
                  Spring Boot (controllers, services, repositories).
                  Data Layer: MySQL + Hibernate/JPA.

 EXPLAIN THE ALGORITHM YOU USED TO GENERATE SHORT URLs. Did You 
       CONSIDER COLLISIONS?
To generate short URLs, I implemented a Base62 encoding approach,
which converts a unique database ID into a compact, alphanumeric string.
  i. Input: A unique long ID (auto-incremented primary key
                              from the "UrlMapping" table).
  ii. Conversion Logic:
   Divide the ID by 62 and map the remainder to a character in the set
   Repeat until the ID becomes 0.
   Reverse the resulting string to get the short code.
 iii. Advanteges:
   Predictable: No randomness, ensuring deterministic output.
        Collision Handling:
While Base62 encoding itself is collision-free
(since each ID maps to a unique string), I implemented additional safeguards:

How did JWT AND SPRING SECURITY INTEGRATE INTO THIS PROJECT? What
ENDPOINTS WERE SECURED? 
   1. JWT (JSON WEB TOKEN) Implementation.
To enable stateless authentication and secure API endpoints by validating user identity and permissions.
Components:
  JwtUtils:Handles token generation, validation and extraction of claims
           (e.g., username, roles).
  JwtAuthenticagtionFilter: Intercepts requests, validates tokens and 
                            sets the SecurityContext.
  JwtAuthenticationResponse: DTO to return the token to the client after
                             login.

   2. Security Best Practices Applied
 i. JWT Security:
    Signed with HMAC-SHA256 ------|
                                  |
HMACSHA256 Is a type of keyed hash algorithm that combines the
SHA-256 hash function with a secret key to produce a 
Hash - based Message Authentication Code(HMAC).
This algorithm is widely used to ensure integrity and authenticity of a
message especially when transmitted over insecure channels.

ii. Input Validation:
       Used @Valid on DTOs (e.g., LoginRequest) to reject malformed
       inputs.
iii. CSRF Protection: Disabled for stateless APIs
                     (since JWT is immune to CSRF).
iv. Rate Limiting: Add Spring Security rate limiting for "/login" and
                   "/register".

  3. Challenges & Solutions:
 i. Challenges: Token revocation(e.g., logout)
Solution: Short - Lived Tokens (Simpler)
 a. Configure Token Expiration
   In "application.properties":
              jwt.expiration=86400000  # 24 hours in milliseconds
   In "JwtUtils.java":
              public String generateToken(UserDetailsImpl userDetails){
              //Set expiration from properties
              return Jwts.builder()
              .subject(userDetails.getUsername())
              .issuedAt(new Date())
              .expiration(new Date(System.currentTimeMillis()
               + jwtExpirationMs))
              .signWith(getSigningkey())
              .compact();
              }
  b. Force Re-login After Expiry
      Clients must refresh tokens by re-authenticating after 24 hours.
      No server side storage needed.

   WHY USE SPRING DATA JPA OVER PLAIN JDBC? WHAT WERE THE ADVANTAGES?
1. Reduced Boilerplate Code
     Problem with JDBC:
       Required manual:
          Connection Management
          SQL query strings
          ResultSet to object mapping
          Transaction handling
     Spring Data JPA Solution
CODE:
public interface UrlMappingRepository extends JpaRepository<UrlMapping, Long> {
Optional<UrlMapping> findByShortUrl(String shortUrl); // Auto-implemented
}
   No SQL: Methods like "findByShortUrl()" generate optimized queries
           automatically
   No manual Mapping: Entities map directly to tables.

2. Built - in CRUD Operations:
     JDBC: Write Insert, Update, Delete queries manually.
     JPA: Inherits ready to use methods:
    url.MappingRepository.save(entity) // Handles both insert/update

         ---------------NOTE--------------
save() checks if the entity is new (e.g., ID is null). If new, it 
performs an INSERT; otherwise, it merges changes with an UPDATE. 
However, this can 
be inefficient for updates because it may trigger a 
redundant SELECT. In my URL shortener, I used save() for new links but 
optimized updates with @Modifying queries when possible
        ----------------X-----------------

 WHY USE SPRING DATA JPA OVER PLAIN JDBC? WHAT WERE THE ADVANTAGES?
1. Reduced Builerplate Code:
    Problem with JDBC:
      Requires manual:
        Connection management
        SQL query strings
        ResultSet to object mapping
        Transaction handling
    Spring Data JPA Solution:
CODE:
public interface UrlMappingRepository extends JpaRepository<UrlMapping, 
Long>{
  Optional<UrlMapping> findBySortUrl(String sortUrl);
}

No SQL: Methods like 'findByShortUrl()' generate optimized queries 
automatically.
No Manual mapping:
  Entities (e.g., UrlMapping) map directly to tables.

2. Built - in CRUD Operations
  JDBC: Write INSERT, UPDATE, DELETE queries manually.
  JPA: inherits ready-to-use methods:
CODE:
urlMappingRepository.save(entity); // andles both insert/update
             urlMappinRepository.deleteById(id);

3. Transaction Management
   JDBC: Manual commit()/rollback().
   JPA: Declaration transaction with '@Transactional'
CODE
    @Transactional
    public void trackClick(String shortUrl){
UrlMapping url = 
urlMappingRepository.findByShortUrl(ShortUrl).orElsrThrow();
url.setClickCount(url.getClickCount()+1); //Auto-saved on method exit
    }
4. Performance Optimizations
   Lazy Loading:
CODE
    @OneToMany(mappedBy = "urlMapping", fetch = FetchType.LAZY)
    private List<ClickEvent> clickEvents; //Loaded only when

   Caching: First - level cache (Persistence Context) reduces
            database hits.
5. Database Portability
   JDBC: SQL queries may need rewriting for different databases.
         (e.g., MySQL -> PostgreSQL)
   JPA : Uses Hibernate's dialect system to auto - generate 
         vendor - specific SQL.
6. Type Safety
  JDBC: Risk of SQL injection or typos in query strings:
CODE:
    String sql = "SELECT * FROM url_mapping" WHERE short_url = ''
  JPA: Compile - time checks:
CODE:
    findByShortUrl(String shortUrl);
     // Compiler validates method name/parameters
7. Auditing & Hooks
    Automatic timestamps:
CODE
    @EntityListeners(AuditingEntityListener.class)
    public class UrlMapping {
      @CreatedDate
      private LocalDateTime createdDate;
    }
8. Integration with Spring Ecosystem
     Pagination:
CODE:
      Page<UrlMapping> findAll(Pageable pageable);
       // Auto-handle Limit/offset

     QueryDSL Support: 
      Type - safe dynamic queries.

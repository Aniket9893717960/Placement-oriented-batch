         Building Towards topic:
Now basically when u talk about applications,
I'm talking about enterprise level application.
Now, initally those application used to stay in on permise.
Basically every company will have their own servers and they will 
deploy the application on their own servers.

but then we have talked about cloud, right? Now most of the companies
are moving from on premise to cloud. So, basically all the services 
which we are using nowadays is cloud based.

Even the public application like Google Docs, Dropbox, Gmail, everything 
is cloud. Now the application which are used internally in the company,
they are also deployed on the cloud.

 Of course Not every Company is moving into it.
 but majorly, most of the applications are on cloud nowadays.
 Now, the moment u talk about cloud applications, We have 
 Two interesting terms here:
   CLOUD READY                         CLOUD NATIVE

It's IMP to understand difference b/w this 2. What we expect from the 
 cloud application is the cloud services. The moment u talk about
 cloud, it provides a lot of different benefits, right?

 Benefits in term of cost. 
 Benefits in term of scaling.
 Benefits in term of less issues.

 Now. if u want to achieve that, of course, U have to make an application
 which will use all those services and which will fullfill the promises,
 right? But what happens is the application which are deployed on the
 cloud out of two types, one is cloud-ready,
  2nd is cloud Native.

                WHAT DO U MEAN BY CLOUD READY?
let's say u already have an application in your premises, okay?
Or in your own local server. Now u want to move that particular
application on the cloud.

U make same changes Not like U picked up the application and throw it
on the cloud. No, that's not how it works.

basically u have to make some changes to your existing application and
u have to make it cloud ready, maybe work With the environment variable,
maybe work with the configuration files, And make sure that u are able 
to push your application on the cloud and u should be able to use the 
services.

So, u are basically making your non cloud ready application to cloud-ready
as simple as that. But on the other hand, if u really want to use all the 
cloud services And if u want to make it more effective.

                      CLOUD NATIVE?
U have to build an application as cloud native. Now normally, these type
of applications are new application.
Let's say u have to decide now. Do u want to build on premise or do
u want to use it on the cloud? And the moment u say, okay, that's what 
we are going for, we want to build an application which is for cloud,
make sure it is cloud native.

So, that u can use all the features. But how exactly u make a cloud native
application? In fact, the name itself says right, native. So, it is meant
for cloud. right? Now if u want to achieve this we can follow certain
standards and rules.

So, "HEROKU" has created some standard for u and u can follow them to 
build a better application for cloud, basically a cloud native 
application Of course right. How do u define a cloud native application?

So, just follow the rules and u are done. the thing is this rules actually
made a long back. And Now we have few changes, Now we talk about those
rules which have been developed  At that Point called 12 Factor App.

                      12 Factor App?
 1. CODEBASE:
 Now basically what happens is we normally store all the coding files
 in your folder, right? So basically when u make a project, U store that
 in your project.

 Maybe in IDE or any data which u use. Now, what code base says is if u 
 want to build a cloud native application, u have to make sure that your
 code base is using a version control.

 For Example: 
 One code base track in a revision control and many deploys.
 So, basically we can use something like a Git here.

 In Git u have to make sure that u store your project there in a local
 or maybe u can use some remote repositories, let's say Git Github And We
 have multiple options there.

 "U Have one Code Base For Development, Testing, Production, Analysis 
 too in one repository. And then u have a multipke deployments in staging"
  The thing is "U have one codebase for one application".

 Yeah, if u have one code base for multiple application, that's where 
 you're making rules. So, make sure that u have one code base for one
 application and not even multiple apps in one code base.
             "One code base for one application"

     2. DEPENDENCIES
there are multiple dependencies which u work with.
Example: In Java we have to work with let's say i want to use database
         Connection. So, if u have to use a dependency for database,
         maybe u want to do it for logging, u need one dependency for 
         logging as well.
Now tendencies, when u build a project, in fact we should do that in the
earlier days, when u build a project, there's a folder which says 
libraries. And this is where u put all your packages and java files.

Okay for this particular project, I got all these dependencies. when
u want to basically give this project to someone else, may be u have
opp's team to deploy the application.

Now u will give these all java files as well to them. That's not a good
idea. where u say,"Okay, this project needs this dependencies and
there might be some version issues."

Maybe u are using 2.5 for particular dependency and the ops team are 
using 2.6 or 2.4.
There might be some issues, right? So, make sure that u have a separate
file, like a manifest file example. In Java, we use Maven.
U mention all the dependencies which u need with versions. And u keep it 
something U Don't link it to your code base.

Now when u share this code with someone else, u also share this dependen
cies, the manifest file, not the actual dependencies, and they can 
download it with the version and the actual name.
And how u separate it. 

   3. Configuration
U have to basically in your code if u want to connect with a database,
U use a URL, username and password. If u want to use a particular port no.
U mention that in the code itself. So, don't mention any of this stuff,
any of the configuration inside your code.
That's what it says so, store configuation in the environment So, 
basically what u should do is create a different file, may be
an ENV file and save all the values there.

Even if u change your physical servers or anything related to the 
environment u don't have to change your source code, Just change the
environment variable and u are done.
So, the idea is don't touch your code once it is built.

 4. BACKING SERVICE
So it basically relates to the above parts as well. So, what it says
is have a loose coupling between your application and the backing
services.
Now this backing services can be a database, It can be some other third
party services, while u are usin it Example, let say if u are building 
an application and in this application u need some data from the third
party.
So, try to create a separate stuff, treat that service as a resource.
May bein future it mi ht chan e. lets say currently, if u usin MySQL,
in future, u want to use Post res, t at switc in s ould be easy, ri ht?

So, in your code dont hard code the confi ureation, dont specify which
particular resources u want to use. Just say, 
                 Okay i want this resource.
And then u can just confi ure it outside,
{ Okay, for this particular request i have this resource and u can use  
   them.}
So, treat them as a resource, not a part of your application. Next we 
have is build, release and run. One of the tendencies we have is write 
the application, run it. Maybe u can do that on the production as well.
Now u can do it with the development environment on the production as 
well.
    u will say, { Okay, I have a code here, let me run it. }
Dont do that. 

  5. Build release and run:
what u do is u have to follow a three different process,
build, release and run. So, what u do is if u have a project ready.
Create a package, build it maybe in java,u can do it with the Maven.
and once u got your package, maybe a Java file, u can give a release to 
it, maybe a configuration environment, variables and all stuff.

Now this release will go to the running environment, maybe whatever 
environment u using there, whatever servers u have, whatever 
environment, JVM u have there.

And then the thing is, when u release it, u have a particular version to
it, right? and thats working. the advantage would be even if u want to 
make a small change, u will not do any changes in the release version.
what u doing is u changing in the build.

Again u change it, create a new package with a different version. every 
time u release it, u have a different version to it. And if something
goes wrong, u can go back to the previous version because let say,
now u have release 5.5 and then something goes wrong with that u go
back to 5.4.
Let say in 5.5 u got a new feature, u just use it, build a new one,
5.6 and release it. So, version is very important there as well.
So, create a separate thing, build a separate, release a separate,
run is separate.

    6. Processes:
Now basically when we talk about web applications,
---- In the earlier days we used to go for sessions or stateful services.

So, what is stateful basically means is as a client, if u connect to a particular server for the first request and then share some data,
next time when u going to the server, server knows u, server knows who u are, they have the information about u.

It’s a good thing, of course, right? Next time when u go there,
u don’t have to tell everything. U can simply say, I was there. I came there yesterday and now I’m here with a new request.

The thing is, by doing this, U are limiting your resources. Basically u are saying, okay. U got this stateful service, and what if something goes wrong.

         What the stateful service? A client will say,
     { Okay, I was there yesterday, the data is lost now. }

So, the idea is instead going for stateful, go for stateless.
Where every process is just a process. It’s not storing any data in the process.

So, every time u get a new request, u say
{ Okay, I got request, let me process it. } and if there any data involved, the data should be coming from the attached resources.

It can be a databases or some other server, but make sure that u not storing anything.

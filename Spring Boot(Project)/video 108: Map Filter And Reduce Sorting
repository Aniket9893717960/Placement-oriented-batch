First we talk about filter  method
                    -------
U can see 'Filter' needs an 'Object' of 'Predicate'
                 Main Question is What is Predicate ?
                 ------------------------------------

So, to work with predicate first we have to import 
  'java.util.function.Predicate' And i will click 'Predicate' 
  here SO, 'Predicate' is an Interface which belongs to a method
  'test' or this 'test' method will retruns you a boolean value.
And based on this 'boolean' value it can be either true or false.

If for the 'stream' we apply a particular value. if it's 'true'
  then we go ahead otherwise we stop.
So, let's implement a 'predicate' here.

  Predicate<Integer> p = new Predicate<Integer>(){
    //'Predicate' is an interface that's why we use Anonymous method here.
  };
Now we were adding the implementation method. to 
support 'Predicate' interface.
  
  public boolean test(Integer n){
    return false;
  }

  Now in this method we gonna check that if n is an even no
    then it return 'true' else return 'false'.

Now instead of 'n-> n%2==0' we previously putted in filter method
i can put 'p' at the command like this:

      List<Integer> nums = Arrays.asList(4,5,7,3,2,6);

    Predicate<Integer> p = new Predicate<Integer>(){
        public boolean test(Integer n){
            return n%2==0;
        }
    };

  int result = nums.stream()
                    .filter(p)
                    .map(n -> n*2)
                     .reduce(0, (c,e) -> c+e);

          System.out.println(result);

In 'Predicate' will be override the 'Functional Interface'
that's why we use lembda Expression here.

        Predicate<Integer> p = (n) -> n%2==0;

  And you have '(n) -> n%2==0' expression here.

This is how the 'Filter' works.
----------------------------------X------------------------------------------------
Now Next Topic Is 'Map' So, let's see How 'Map' work?
         If i go to 'Map' So, 'Map' Needs Object of the 'function'.
'Function' is this Function Interface which have two types. 
And we have given the method called 'apply'.
So, Now can we do it we have calling the method 'function'.
Now the function takes two types
      i. what it's accept 
      ii. what is return

           Function<Integer, Integer> fun = new Function<Integer, Integer>();

we have given the object 'Function' name is 'fun' which have the anonymous 
method. This will have only one method called 'apply'.
                   public Integer apply(Integer n){
                       return null;
                   }  
Whatever we wanna 'return' at 'Integer' parameter 'n' u just apply the value 
And we all know that it's the functional Interface.
     Now we will take 'fun' from 'Function<Integer, Integer>' put it in
     'map'.

Now we can do is this compress the data.
                  Function<Integer, Integer> fun = n -> n*2;
U know in 'fun' we just initialize the data So, you don't even need this :
                         .map(n -> n*2)
---------------------------------X-------------------------------------------------
We will come from 'Reduce' So, 'Reduce' will take two parameters
     i. Type
      ii. Operation called 'BinaryOperator<T>  accumlator'

So, what is 'BinaryOperator<T>' will extends 'BiFunction' and 
'ByFunction' is the method called 'apply'

If we talk about 'reduce' so, how we will 'reduce' a value
Example : Let's say if i ask you to add 3 no. let's say 
          1,2,3 so, how to add them So, in your mid you are 
Doing this let's say 1 , 2, 3, 4 how will you add them.

Of course u can not add all the method at the same time u only
add two values at the same time.
So, First of all add
       C     E  where C is Carry and 'E' has Element.
       1 and 2 they will give you 3 after that we will write 
       3 and 3 You will got 6 then we add
       6 and 4 which will give you 10.
So, that you will add 2 values at the time and if you want to
simplify this you can start from zero.
That's why we assign '0' in variable 'sum'

Of course you will not done this with implementation but u got my
point.
'Stream' is Cool We apply multiple functions here In fact let me 
show you one more thing what if i don't want 'int result' in
between i want a 'Stream' itself. 
But i want the 'Stream' to be sorted I want a 'Stream' itself But i want the 
'Stream' to be sorted so, i will say Integer' then sorted value.
and i don't want to 'map' and 'reduce' we just use only one method 
after the data is 'sorted'.

       Stream<Integer> sortedValues = nums.stream()
                                          .filter(n -> n%2==0)
                                          .sorted();
           System.out.println(sortedValues); //u got Ops$OfRef@58644d46
        But we try to print sorted values so, it will printed help of 'for-each'

           sortedValues.forEach(n -> System.out.println());

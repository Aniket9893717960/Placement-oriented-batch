                 WHAT IS A "HashSet"?
*A HashSet is a Set implementation based on hashing.
*It stores only unique elements.
*It uses a "HashMap" internally to manage those elements.
*You don't see the map, but everything u add to the "HashSet" goes into a 
 "HashMap" behind the scenes.
  CODE:
          HashSet<E> set = new HashSet<>();
          set.add("Apple");
   // Internally: HashMap<E, Object> map = new HashMap<>();

*A dummy object called "PRESENT"(usually new Object()) is stored as the 
 value:
  CODE:
          map.put(element, PRESENT);

    #Internal Working Of "add()" in HashSet
  Steps that happen when u call 'add()':
 Let's say
 CODE:
      set.add("Apple");
 
 STEP 1: "HashCode()" is called
 Java first calls:
      int hash = "Aniket".hashCode(); // Suppose it returns 123456
 This 'hashCode()' gives a unique integer for the object, based on its
 content.
  *For 'String', it's based on its characters.
  *For custom objects (like 'Student','Employee'), u can override 
   'hashCode()'.

  STEP 2: Compute Bucket Index:
  Java uses this hash to find the index (bucket) in an internal array
  (hash table). For Example:
  CODE:
       index = hash % capacity;
  *Default capacity = 16 initially
  *Suppose "123456%16=0", so it goes to bucket 0.

  STEP 3: Check for existing entries in the bucket
  If bucket is empty, it stores the element directly.
  If not empty (Collision), it checks existing elements one by one.

Here's where 'equals()' comes into play.

  STEP 4:'equals()' is used to check for duplicates.
  For example:
          set.add("Aniket");
          set.add("Aniket"); // Trying to add same value
Even if the hash codes match and go to the same bucket, it calls 
'equals()' to compare:
  CODE:
  "Aniket".equals("Aniket"); // returns true -> duplicate -> not added
       So, 'hashCode()' is used to locate and 'equals()' is used to
          verify.

     #Collision handling in HashSet
  What if two different elements have the same hashCode?
  CODE:
       String str1 = "FB"; //hashCode() = 2236
       String str2 = "Ea" // hashCode() = 2236
       HashSet<String> set = new HashSet<>();
       set.add("FB");
       set.add("Ea");  // Different Strings, but same hashCode!

  Same bucket due to same hash -> Java now checks:
  CODE:
       "FB".equals("Ea"); //false -> So both are stored in same 
                          bucket (as a Linked list or tree)

     #HashSet Bucket Structure
 Internally, "HashMap"(used by 'HashSet') has an array of buckets.
 Each bucket stores a linked list or a tree of entries 
 (In case of collision):
     Index   Bucket (key, value)
     0       "Aniket" -> "Sumit" -> "Nikita" (if same hash)
     1       null
     2       "Rahul"
     3       null

     #Tree after Java 8(Treeification)
 If many elements land in the same bucket (>= 8 items by default),
 Java converts that bucket from a linked list to a balanced tree for
 better performance.
    *Why? Linked list search is O(n), tree is O(log n).
    *This is called Treeification.

  # Real Custom Class Example (Very Important for Interviews)
 Let's say we have a class "Student":
 CODE:
   class Student {
   int id;
   String name;
    public Student(int id, String name){
     this.id = id;
     this.name = name;
    }
   @Override
    public int hashCode(){
     return id; //simplified for demo
    }
   @Override
    public boolean equals(Object o){
     if(this==0) return true;
     if(!(o instanceof Student)) return false;
     Student s = (Student) o;
     return this.id == s.id && this.name.equals(s.name);
    }
   }

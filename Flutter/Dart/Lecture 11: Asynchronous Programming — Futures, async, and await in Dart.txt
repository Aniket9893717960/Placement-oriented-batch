         1. Why Asynchronous Code? Real life Comparisons?
Imagine baking a cake. while it's in the oven for 30 minutes, u don't Just
stare at it - u clean up, text your friend, or perpare toppings. Programs
need this multitasking too!
              Real - world need:
Apps often wait for things: loading a file, fetching data from the internet,
Waiting for a user to tap a button. if code waits and does nothing, the 
whole app "freezes" for everyone. Not good!
        i. Why did Dart get asynchronous features?
Early web/modile apps often locked up while waiting for slow tasks.
Dart's designers wanted a simple, readable way to handle multitasking
So one slow job wouldn't block everything else.

                       2. What are Futures?
A Future in Dart is a promise: "I'll get u the result later - Keep Working
 meanwhile!". Example:
Future<int> fetchScore() async { return 88; // Imagine getting score from a
 server}
here, 'Future<Int>' means "This function will give an integer.. but not
       right away."
 i. Why Futures? they fits how the real world works. Some results come
         instantly, others take time. Futures let Dart handle both in a 
     consistent, safe way.

         3. async and await - Turning Waiting into simple Code
*async marks a function as able to pause and wait for slow jobs.
*await politely tells Dart,"Pause here, finish the slow job,then move 
on". Example:
          void main() async { print('Loading...');
          var score = await fetchScore();
          print('Your score: $score'); }
*Dart prints "Loading...," waits for 'fetchScore()',then prints the 
 result.
      i. Why async/ await? :
 Before async/await, handling slow tasks meant complicated, hard to read
 code. Dart designers chose this system to keep code as readable as 
 normal, while handling real world delays effortlessly.

         4. Streams - Handling Many Outputs Over Time
Sometimes, u want to read a bunch of values as they arrive (like 
Listening to live chat messages or sensor data). Dart uses Streams for 
this. Example:
      Stream<int> numberStream() async* {
        for(int i=1;i<=5;i++){
        await Future.delayed(Duration(seconds: 1));
        yield i; }
      }

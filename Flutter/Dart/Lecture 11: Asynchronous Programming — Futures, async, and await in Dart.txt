         1. Why Asynchronous Code? Real life Comparisons?
Imagine baking a cake. while it's in the oven for 30 minutes, u don't Just
stare at it - u clean up, text your friend, or perpare toppings. Programs
need this multitasking too!
              Real - world need:
Apps often wait for things: loading a file, fetching data from the internet,
Waiting for a user to tap a button. if code waits and does nothing, the 
whole app "freezes" for everyone. Not good!
        i. Why did Dart get asynchronous features?
Early web/modile apps often locked up while waiting for slow tasks.
Dart's designers wanted a simple, readable way to handle multitasking
So one slow job wouldn't block everything else.

                       2. What are Futures?
A Future in Dart is a promise: "I'll get u the result later - Keep Working
 meanwhile!". Example:
Future<int> fetchScore() async { return 88; // Imagine getting score from a
 server}
here, 'Future<Int>' means "This function will give an integer.. but not
       right away."
 i. Why Futures? they fits how the real world works. Some results come
         instantly, others take time. Futures let Dart handle both in a 
     consistent, safe way.

         3. async and await - Turning Waiting into simple Code
*async marks a function as able to pause and wait for slow jobs.
*await politely tells Dart,"Pause here, finish the slow job,then move 
on". Example:
          void main() async { print('Loading...');
          var score = await fetchScore();
          print('Your score: $score'); }
*Dart prints "Loading...," waits for 'fetchScore()',then prints the 
 result.
      i. Why async/ await? :
 Before async/await, handling slow tasks meant complicated, hard to read
 code. Dart designers chose this system to keep code as readable as 
 normal, while handling real world delays effortlessly.

         4. Streams - Handling Many Outputs Over Time
Sometimes, u want to read a bunch of values as they arrive (like 
Listening to live chat messages or sensor data). Dart uses Streams for 
this. Example:
      Stream<int> numberStream() async* {
        for(int i=1;i<=5;i++){
        await Future.delayed(Duration(seconds: 1));
        yield i; }
      }
        *Here, numbers 1-5 are sent out, one each second.
 i. Why Streams? Modern apps aren't just about one result - they often 
                 handle many events over time (music, notification, 
   stock prices). Dart added streams so u can process ongoing data,
   piece by piece, as it arrives.

               5. Error Handling in Async code:
 Just like with normal code, slow jobs can fail Dart lets u catch and
 handle these errors inside async functions.
 Example:      try { var score = await fetchScore(); }
            catch(e){ print('Failed to fetch score: $e'); }
 i.Why? Async jobs are often flaky (bad network, server down).
      Dart ensures u can manage those issues smartly, without crashing
     your app.

           6. Why Dart's Asynchronous Model is Special
*Simple syntax: async/await reads top to bottom, not left to right
               with confusing collbacks.
*Consistency: same rules for files, networks and times.
*Safe and scalable: Built for today's apps - chat, social media, games
                    where dozens of things happen at once.

                  7. Summary Of Lecture 11
*Asynchronous Programming lets Dart apps stay fast, smooth and 
 modern - never frozen!
*Futures, async and await make code readable and multitasking easy.
*Streams handle many values/events reliably and multitasking easy.
*Dart's async features were designed to handle real world app needs,
 simply and safely.

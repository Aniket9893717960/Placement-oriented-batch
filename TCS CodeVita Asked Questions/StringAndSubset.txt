You are given N comma-separated Strings. You need to form all possible legal subsets of these N strings. These subsets will be a combination of zero or more of these N Strings After forming the subsets, they will be ranked in a particular onder. The legal subset formation and ranking logic is as described below Rank 1 will always be an empty set Next N ranks will be the N Strings that appear in the order they are provided in the input After N + 1 ranks, you need to combine N strings such that all legal combinations are formed Legal combination simply means that while combinations are formed, the string that appears to the left of a particular string in the input, can never appear to the right of that particular string, when subsets are formed A subset with less elements will be ranked higher than a subset with more elements (NOTE-Rank 1 is higher than rank 2) Refer Example 2 to get a better understanding of how subsets are formed and ranked It is guaranteed that N>=1 All N strings are unique Example: you are having an input string “aa,cc,bb” in this string we can see we have three strings which are comma separated. Now from this group of string we have to create all possible subset of strings. 8 subsets can be formed from these strings. And they are as follows: {} {aa} {cc} {bb} {aa,} Note: here we can see the ranks given to the subsets are first by size i.e., the subset with lesser number of strings is ranked higher than the subset with higher size. If the subsets have equal number of strings then, the combination which is formed earlier (by virtue of combining strings in order they appear in input), gets a higher rank. For example, rank of su bset (aa,cc) > rank of (aa,bb) because string cc is appearing prior to string bb in the input. Similarly, rank of (cc) > rank of (bb). You are provided one rank R and for that you have to print the Rth subset from all legal subsets.

Constraints:

0<N<=10^2

0<R<=10^18

Input

First line contains an integer N which is number of strings in group.

Second line contains an integer R, for which you have to find Rth subset from all legal subsets.

Third line contains N comma-separated strings basis which the subsets should be formed

Output:

From all possible legal subsets find the subset whose rank is R

Time Limit (secs)

1

Input

2 4 a,b

Output

a,b

Explanation: Given that N = 2, given Second line: Rank to be find: 4th Third line: Given group of strings: a,b Possible subsets & Rank {}-1 {a} -2 {b}-3 {a, b}-4 Output – a,b (4th rank corresponds to a,b)

                                ANSWER :-

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
import java.util.Arrays;
import java.util.Collections;
public class Main {
	public static void main(String[] args) {
    	Scanner scanner = new Scanner(System.in);
    	int N = scanner.nextInt();
    	int R = scanner.nextInt();
    	scanner.nextLine();
    	String[] strings = scanner.nextLine().split(",");
    	List< List< String>> subsets = generateSubsets(strings);
    	if (R <= subsets.size()) {
        	List< String> result = subsets.get(R - 1);
        	System.out.println(String.join(",", result));
    	} else {
        	System.out.println("Rank exceeds the number of subsets.");
    	}
	}
	public static List<  List> generateSubsets(String[] strings) {
    	List< List< String>> subsets = new ArrayList<>();
    	int n = strings.length;
    	subsets.add(new ArrayList<>());
    	for (int i = 0; i < n; i++) {
        	subsets.add(Collections.singletonList(strings[i]));
    	}
    	for (int subsetSize = 2; subsetSize <= n; subsetSize++) {
        	List< List< String>> combinations = getCombinations(strings, subsetSize);
        	for (List< String> combination : combinations) {
            	boolean validCombination = true;
            	for (int i = 0; i < combination.size() - 1; i++) {
                	if (Arrays.asList(strings).indexOf(combination.get(i)) > Arrays.asList(strings).indexOf(combination.get(i + 1))) {
                    	validCombination = false;
                    	break;
                	}
            	}
            	if (validCombination) {
                	subsets.add(new ArrayList<>(combination));
            	}
        	}
    	}
    	return subsets;
	}
	public static List< List> getCombinations(String[] strings, int subsetSize) {
    	List< List> combinations = new ArrayList<>();
    	generateCombinations(strings, subsetSize, 0, new ArrayList<>(), combinations);
    	return combinations;
	}
	public static void generateCombinations(String[] strings, int subsetSize, int index, List< String> currentCombination, List< List> combinations) {
    	if (subsetSize == 0) {
        	combinations.add(new ArrayList<>(currentCombination));
        	return;
    	}
    	if (index >= strings.length) {
        	return;
    	}
    	currentCombination.add(strings[index]);
    	generateCombinations(strings, subsetSize - 1, index + 1, currentCombination, combinations);
    	currentCombination.remove(currentCombination.size() - 1);
    	generateCombinations(strings, subsetSize, index + 1, currentCombination, combinations);
	}
}

Till this point we were able to store the object because this object has 
very simple values.
Talking about Integer, String all this are basic java types And also
on the database side.
we are using JDBC here we have something called JDBC type with Checks
we have 'Int' so what we need in Database to basically try to match it.
For             Int  we got           Integer  there
                char we got           Varchar there
But what if u got the complex type.
  Example :
  let's say if we have a laptop of 
    Brand: Asus
    Model: ROG
    RAM : 16 GB
    CPU : i7
    Graphics: RTX 3060

U know this details will be visible like this:
    12th Gen Intel(R) Core(TM) i5-12450HX   2.40 GHz
    
And we want to fatch specific value's in this String So, 
    To store this in string is not a good idea.

So, what we can do is we can generate the Seperate class here
  Which is of type laptop in 'org.aniket12' package

In those 'Laptop' class we store private variables are:
              private String brand;
              private String model;
              private int ram;

And for this particular variables we need an auto generate getter's
setter's and we also generate the toString. 
So, this is all i have there is no primary key if u observe
i don't have the intention to create the laptop.

Go back to 'alian' what can i do is Instead of having a 'String' here
we want to specify this is a complex type.
This is the reference variable here 'laptop' not a simple type int,
String.

In 'alien.java' we specify 
               private Laptop laptop;
And also builded Getter's and Setter's with toString of it.

If i go back to 'Main.java' with 'alien' data i want to take
the data of laptop as well.
              'a1.setLaptop();' but before u create 'Alien' first
we create a laptop object. So,
                  Laptop l1 = new Laptop();
And to set the data in l1 object we write 
                  l1.setBrand('Asus');
                  l1.setModel('Rog');
                  l1.setRam(16); 

And once i got the object we put 'l1' at
                  a1.setLaptop(l1);

Instead of going to Int and String we go for the complex type. If i
run this code will it work That's the bigest Question.
Let's try or Let's understand with the error in case. 

"Could not determine recommended JdbcType for Java type 'org.aniketdb1.Laptop'"
It means compiler will don't know what the hell is 'Laptop'.
But We doen't just put package of 'laptop.java' in 'alian.java' because
it create it's own table. And i don't want to have it's own table what i want
is Table Structure.
Example:
               aid       aname        tech          But for laptop i coudn't want
                                                    the single field we want 'laptop'
                                                  field as 3 different fields in 
                                                  same 'Alien' table.

We want to 'laptop' embedded inside the 'alien' If u want to make it work the laptop
should be embeddedable. And to Achieve that we simple says
'@Embeddable' At the top of 'Laptop' class at 'laptop.java'.
And once i do that i go back here and just done 1 change i give the permission that
'laptop' will be embedded.

This is the final Program.

import org.hibernate.Session;
import org.hibernate.Transaction;
import org.hibernate.SessionFactory;
import org.hibernate.cfg.Configuration;

// we start work on this main From Video no 139

public class Main {
    public static void main(String args[]){

        Laptop l1 = new Laptop();
        l1.setBrand("Asus");
        l1.setModel("Rog");
        l1.setRam(16);

        Alien a1 = new Alien();
        a1.setAid(101);
        a1.setAname("Navin");
        a1.setTech("Java");
        a1.setLaptop(l1);

        SessionFactory sf = new Configuration()
                .addAnnotatedClass(org.aniketdb1.Alien.class)
                .configure()
                .buildSessionFactory();

        Session session = sf.openSession();


        Transaction tx = session.beginTransaction();

        //session.persist(a1);

        Alien a2 = session.get(Alien.class, 101);
        System.out.print(a2);

        tx.commit();
        session.close();
        sf.close();

    }
}

But the probblem is in fatching part it doen't find the select Query it find the In
sert Query This will gonna we talk about why It's not sending the select Query?
We will talk about this in upcoming videos why u are saying get.

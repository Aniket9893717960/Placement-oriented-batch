             -------------------X-----------------
CAN U WALK ME THROUGH HOW U IMPLEMENTED AUTHENTICATION AND 
AUTHORIZATION IN YOUR PROJECT USING SPRING SECURITY AND JWT? 
SPECIFICALLY, I'D LIKE TO UNDERSTAND "WEBSECURITYCONFIG" SETUP,
YOUR CUSTOM JWT FILTER, AND HOW U TRIED IT TOGETHER WITH THE 
"USERDETAILS" SERVICE.

 1. Core Security Confiuration(WebSecurityConfig): This is where i laid
    ------------------------------- the foundation. if u look at 
    'WebSecurityConfig", u'll see I used the '@EnableWebSecurity'
  annotation to enable Spring's web security support. The most critical
 part is the SecurityFilterChain bean:

  // Inside 'WebSecurityConfig.java'
 @Bean public SecurityFilterChain securityFilterChain(HttpSecurity http)
 throws Exception {
 http.csrf(AbstractHttpConfigure::disable)
 .exceptionHandling(exception -> 
exception.authenticationEntryPoint(unauthorizedHandler))
 .sessionManagement(session -> 
session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
.authorizeHttpRequests(auth ->
  auth.requestMatchers("/api/auth/public/**").permitAll()
  .requestMatchers("/{shortURL}").permitAll()
  .anyRequest().authenticated());
 http.authenticationProvider(authenticationProvider());
 http.addFilterBefore(authenticationJwtTokenFilter(), 
        UsernamePasswordAuthernticationFilter.class); 
 return http.build(); }

 2. The JWT Authentication Filter (JwtAuthFilter.java)
This is the custom Filter i just mentioned. It's the real workhorse
of the JWT validation process. It extends 
'OncePerRequeestFilter' to ensure it runs exactly once for every 
Request.
Inside its doFilterInternal method, I implemented this logic: CODE:
  //Inside JwtAuthFilter.java

 @Override protected void doFilterInternal(HttpServletRequest request,
   HttpServletResponse response, FilterChain filterChain) throws
   ServletException, IOException {
    try {
       String jwt = parseJwt(request);
     if(jwt!=null && jwtUtils.validateJwtToken(jwt)){
       String username = jwtUtils.getUserNameFromJwtToken(jwt);
       UserDetails userDetails = userDetailsService.loadUserByUsername
      (username);
      UsernamePasswordAuthenticationToken authentication = 
  new UsernamePasswordAuthenticationToken(userDetails, null, 
  userDetails.getAuthorities());
    authentication.setDetails(new WebAuthenticationDetailsSource().
      buildDetails(request));
   SecurityContextHolder.getContext().setAuthentication(authentication);
  } } catch(Exception e){ logger.error("CannotSetUserAuthentication: {
}",e); }
 filterChain.doFilter(request, response);
     }
    }
   }

3. JWT Generation and Utilities (JwtUtils.java And AuthController.java)
The JwtUtils.java class is a helper I created to handle the JWT 
mechanics using the 'io.jsonwebtoken.jjwt' library. it has two main
methods: 'generateJwtToken' and 'ValidateJwtToken'.
I used the 'generateJwtToken' method within the 'AuthController.java'
after a user successfully logs in:
         // Inside AuthController.java
 @PostMapping("/public/login")
 public ResponseEntity<?> loginUser(@ResponseBody LoginRequest 
 loginRequest){
  String jwt = jwtUtils.generateToken(authentication);
 }

So, putting it all together:
 *A user logs in via the AuthController.
 *If successful, JwtUtils generates a token.
 *For all subsequent requests to protected endpoints, my JwtAuthFilter
 kicks in, uses 'JwtUtils' to validate the token, and then uses 
 'UserDetailsServiceImpl' to load the user and set the security 
 context. 
 *And all of this is orchestrated by the rules I defined in 
 'WebSecurityConfig'.
                  -------------------X-----------------
 WHAT FLOW DID U IMPLEMENT FOR AUTHENTICATE USERS TO MANAGE THERE URLs?
       OR            DASHBOARD FOR AUTHENTICATED USERS?
          The Goal: Securely Fetch URLs for a Specific User
The core task is to create an API endpoint that, when called, returns
a list of URLs belonging only to the currently logging in user.
 Step 1: Security - Protecting the Endpoint: First, we must ensure only
 ------------------------------------------ authenticated users can ask
    for their URLs. This is done with Spring Security.
   *How: The 'UrlMappingController' uses the 
 '@PreAuthorize("hasRole('USER')")' Annotation. This acts as a guard. if
 a request comes from someone who is not logged in or doesn't have the 
 USER role, the system rejects it immediately with a "Forbidden" error.
 *Code (UrlMappingController.java):
  ---------------------------------
     @GetMapping("/myurls")
   @PreAuthorize("hasRole('USER')") // <-- This is Security Guard
 public ResponseEntity<Page<UrlMappingDTO>> getUserUrls(
       Principal principal,
@PageableDefault(size=10, sort="clickDate",direction = Sort.Direction.DESC)
Pageable pageable){ User user = 
userService.findByUsername(principal.getName());
try { Page<UrlMappingDTO> urls = urlMappingService.getUrlByUser(user,
 pageable); return ResponseEntity.ok(urls);
} catch (Exception e){ return 
ResponseEntity.status(HttpStatus.) }
}

 Step 2: Controller - Handling the incoming Request:
When the frontEnd dashboard loads,  it sends a GET request to
'/api/urls/myurls'. The controller's job is to catch this request,
identify the user, and delegate the work.

 *How: The controller gets a Principal object from Spring Security,
       which holds the logged in user's username. it then passes this
       information to the 'UrlMappingService' to handle the actual logic.
 *CODE (UrlMappingController.java):
        @GetMapping("/myurls")
        @PreAuthorize("hasRole('USER')")
        public ResponseEntity<Pagr<UrlMappingDTO>> getUserUrls(
      Principal principal, @PageableDefault(size = 10) Pageable pageable){
   User user = userSercive.findByUsername(principal.getName());
Page<UrlMappingDTO> urls = urlMappingService.getUrlsByUser(user, pageable);
 return ResponseEntity.ok(urls); }

  Step 3: Service - The Business Logic:
The Service layer contains the "how-to" logic. It takes the 'User' object
from the controller and uses the database repository to find the matching
Urls.
 *How: It calls the 'urlMappingRepository.findByUser(...)' method.
       This is the key step that links the request to the data. After
       getting the data, it converts the database objects (UrlMapping)
       into simpler objects(UrlMappingDTO) to send to the frontend.
 *Code(UrlMappingService.java): 
public Page<UrlMappingDTO>  getUrlsByUser(User user, Pageable pageable)}
Page<UrlMapping> urlPage = urlMappingRespository.findByUser(user, pageable);
 List<UrlMappingDTO> dtos = urlPage.getContext()
  .stream().map(this::convertToDto) // convertToDto is a helper
  .collect(Collectors.toList());
return new PageImpl<>(dtos, pageable, urlPage.getTotalElements()); }

  Step 4: Repository - The Database Interaction:
This is the final layer, which talks to the database. Thanks to Spring
Data JPA, we don't even have to write the SQL query.
    *How: We simply define an interface method with a special name:
        'findByUser'. Spring understands this name and automatically
         generates the correct SQL query.
         (SELECT * FROM url_mapping WHERE user_id = ?)
    *Code (UrlMappingRepository.java):
  @Repository public interface UrlMappingRepository extends 
  <UrlMapping, Long> {
   Page<UrlMapping> findByUser(User user,Pageable pageable); }

 Summary of the flow:
 Request -> Security Check -> Controller -> Service -> Repository ->
 Database
                   -------------------X-----------------
            CLICK TRACKING AND ANALYTICS FOR SHORTENED URLs?
 The feature can be broken down into two main scenarios:
   1. Recording a Click: What happens when a user clicks a short Url.
 2. Retrieving Analytics: How the frontend dashboard requests and
                          receives the click data for display.
                ---X---
 Part 1: How a Click is Recorded? The Primary goal is to log every 
                Single click event and increment the total click 
         counter for the specific URL that was clicked.
   
  Step 1: The Entry Point - RedirectController:
When a user visits a short URL (e.g., http://your-app.com/{shortUrl}),
the request is handled by the 'RedirectController'. This controller's
main job is to redirect the user to the original long URL, but it's also
the perfect place to initiate the click tracking.
 *How: it captures the 'shortUrl' from the path and calls the 
       'UrlMappingService' to do the heavy lifting: find the original
       URL and record the click.
 *Code (RedirectController.java):
  // In src/main/java/com/url/shortener/controller/RedirectController.java
     @RestController
    @RequestMapping("/") public class RedirectController {
       private final UrlMappingService urlMappingService;
       @GetMapping("/{shortUrl}")
     public ResponseEntity<Void> redirect(@PathVariable String shortUrl){
        urlMapping urlMapping = urlMappingService.getOriginalUrl(shortUrl);
       return ResponseEntity.status(HttpStatus.FOUND)
        .location(URL.create(urlMapping.getOriginalUrl()))
        .build();
      }
    }

Step 2: The Logic - UrlMappingService:
The service contains the methods that fetch and process the analytics data
from the database.
 *How: It uses the 'ClickEventRepository' to find all ClickEvent records
      that match the criteria(e.g., belong to a specific user and fall
       within a date range). it then processes this data into a format
      that's easy for the frontend to use like a Map for a graph.
 
 *Code (UrlMappingService.java):
      //In src/main/java/com/url/shortener/service/UrlMappingService.java
   public Map<LocalDate, Long>  getTotalClicksByUserAndDate(User user,
      LocalDateTime start, LocalDateTime end) {
List<UrlMapping> urlMappings = urlMappingRepository.findAllByUser(user);
List<ClickEvent> clickEvents = 
clickEventRepository.findAllByUrlMappingInAndClickDateBetween(
 urlMappings, start, end.plusDays(1));
return clickEvents.stream().collect(Collectors.groupingBy(
    click -> click.getClickDate().toLocalDate(),Collectors.counting()
    ));
   }

Summary Of the Flow:
 *To Record: A user clicks a short link -> RedirectController catches it
 -> UrlMappingService increments the total count and creates a new
  ClickEvent in the database.
 *To Retrieve: The frontend dashboard calls an endpoint on UrlMapping
         Controller -> The controller ask the UrlMappingService for 
    data -> The service queries the ClickEventRepository to get all
 relevant clicks and aggregates them into a clean format to send back 
 to the frontend.

This dual approach of keeping a simple total clickCount for quick display
and a detailed ClickEvent log for rich analytics is a very powerful and 
scalable design.
I hope this gives u a clear and complete picture of the click tracking
functionality.

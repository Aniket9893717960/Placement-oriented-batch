Dependency Injection Is a design pattern used in Software Development -
especially in object oriented programming to reduce tight coupling 
components.
It is a form of Inversion of Control(loC), where the control of creating 
and injecting dependencies is transferred from the class itself to an 
external framework or container (like Spring framework).

 #Let's Understand with an Analogy:
imagine u are assembling a computer.
 * A tightly coupled system is like a motherboard that builds its own
   CPU, RAM, and SSD internally.
 * A loosely coupled system using Dependency Injection is like a 
   motherboard that accepts components (CPU,RAM,SSD) from outside
   - allowing flexibility to change any part easily.

 Key Terms:
Term                  Explanation
Dependency        An object that another object depends on.
Injection         Passing the dependency to a dependent object instead
                  of letting it create the dependency itself.
loC Container      A framework that injects dependencies automatically. 

#Why Use Dependency Injection?
Loosely coupled code.
Better code reusability
easy Unit testing (via mocking).
improved code flexibility and maintainability.

         EXAMPLE WITHOUT DI (TIGHTLY COUPLED):
class Engine {
 public void start() {
  System.out.println("Engine started.");
 }
}
class Car {
 private Engine engine;
 public Car() {
  engine = new Engine(); //Creating dependency intenally
 }
 public void drive(){
  engine.start();
  System.out.println("Car is moving.");
 }
}
Problem: "Car" class is tightly coupled to Engine. Changing "Engine"
         type means modifying "Car" code.

         EXAMPLE WITH DI:
class Engine {
 public void start(){
  System.out.println("engine started.");
 }
}
class Car {
 private Engine engine;

 // Constructor Injection
 public Car(Engine engine){
   this.engine = engine; // Injecting dependency
 }

 public void drive(){
  engine.start();
  System.out.println("Car is moving.");
 }
}


public class Main {
 public static void main(String[] args){
  Engine engine = new Engine();      // Dependency created externally
  Car car = new Car(engine);      //Injecting dependency
  car.drive();
 }
}

         DI in Spring Framework:
Spring automatically manages dependencies using annotations:
  PROGRAM:
 @Component
 class Engine {
  public void start(){
   System.out.println("Engine started.");
  }
 }

@Component
class Car {
 private Engine engine;
 @Autowired
 public Car(Engine engine){
  this.engine = engine;
 }
 public void drive(){
  engine.start();
  System.out.println("Car is moving.");
 }
}

        Summary:
feature                                           Benefit
Removes "new" keyword         Promotes loose coupling
 inside classes     
Centralized dependency        Makes testing easier
 control
Different types:              Use based on need
COnstructor, Setter, Field    (Constructor is preferred)
Common in Spring              Uses annotations like 
Framework                     @Autowired, @Component, etc.

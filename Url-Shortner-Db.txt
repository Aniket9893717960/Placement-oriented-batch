         Give me an overview about Your Project?
Url shortener a full stack web application to convert long URLs 
into short, shareable links while providing analytics on click -
through rates.
I have used some technologies in backend like:
Framework: Spring Boot (Java)
Database: MySQL (Stores users, URL mappings, and click events)
Authentication: JWT (Stateless, role-based access control)
APIs: RESTful endpoints for URL shortening,
       redirection and analytics.
   i. URL Shortening:
  Use Base62 encoding for compact, collision-resistant short codes.
  ii. Redirection:
  Handles high-volume redirects (HTTP 302) with minimal latency.
  iii. User Authentication:
  Secure registration/login using JWT tokens.
  Role-based access (e.g., ROLE_USER for basic features).
  iv. Analytics Dashboard:
  Visualizes click -through rates, geographic data(if implemented)
  and peak traffic times.
  support date-range filtering and pagination.
  v. Scalability:
  Stateless backend architecture for horizontal scaling.
  Caching (Redis) for frequently 
         Architecture:
             3-Tier Design:
                  Presentation Layer: React frontend (if applicable).
                  Application Layer: 
                  Spring Boot (controllers, services, repositories).
                  Data Layer: MySQL + Hibernate/JPA.

 EXPLAIN THE ALGORITHM YOU USED TO GENERATE SHORT URLs. Did You 
       CONSIDER COLLISIONS?
To generate short URLs, I implemented a Base62 encoding approach,
which converts a unique database ID into a compact, alphanumeric string.
  i. Input: A unique long ID (auto-incremented primary key
                              from the "UrlMapping" table).
  ii. Conversion Logic:
   Divide the ID by 62 and map the remainder to a character in the set
   Repeat until the ID becomes 0.
   Reverse the resulting string to get the short code.
 iii. Advanteges:
   Predictable: No randomness, ensuring deterministic output.
        Collision Handling:
While Base62 encoding itself is collision-free
(since each ID maps to a unique string), I implemented additional safeguards:

How did JWT AND SPRING SECURITY INTEGRATE INTO THIS PROJECT? What
ENDPOINTS WERE SECURED? 
   1. JWT (JSON WEB TOKEN) Implementation.
To enable stateless authentication and secure API endpoints by validating user identity and permissions.
Components:
  JwtUtils:Handles token generation, validation and extraction of claims
           (e.g., username, roles).
  JwtAuthenticagtionFilter: Intercepts requests, validates tokens and 
                            sets the SecurityContext.
  JwtAuthenticationResponse: DTO to return the token to the client after
                             login.

   2. Security Best Practices Applied
 i. JWT Security:
    Signed with HMAC-SHA256 ------|
                                  |
HMACSHA256 Is a type of keyed hash algorithm that combines the
SHA-256 hash function with a secret key to produce a 
Hash - based Message Authentication Code(HMAC).
This algorithm is widely used to ensure integrity and authenticity of a
message especially when transmitted over insecure channels.

ii. Input Validation:
       Used @Valid on DTOs (e.g., LoginRequest) to reject malformed
       inputs.
iii. CSRF Protection: Disabled for stateless APIs
                     (since JWT is immune to CSRF).
